	end
snippet case  case() .. 
	case(${1:expression})
	    ${2:value1}: begin
	       ${3}
	    end
	
	    // other case branches
	
	    default: begin
	
	    end
	endcase
snippet case  casex() .. 
	casex(${1:expression})
	    ${2:value1}: begin
	       ${3}
	    end
	
	    // other case branches
	
	    default: begin
	
	    end
	endcase
snippet casex  casex() .. 
	casex(${1:expression})
	    ${2:value1}: begin
	       ${3}
	    end
	
	    // other case branches
	
	    default: begin
	
	    end
	endcase
snippet case  casez() .. 
	casez(${1:expression})
	    ${2:value1}: begin
	       ${3}
	    end
	
	    // other case branches
	
	    default: begin
	
	    end
	endcase
snippet casez  casez() .. 
	casez(${1:expression})
	    ${2:value1}: begin
	       ${3}
	    end
	
	    // other case branches
	
	    default: begin
	
	    end
	endcase
snippet class  class .. endclass
	//class ${1:class_name} ;
	//
	class $1 ;
	    // Group: Variables


	    // Group: Constraints


	    // Group: Function


	    // Constructor: new


	    function new(string name = "$1");
	       ${2}
	    endfunction: new
	
	endclass: $1
snippet clocking  clocking .. { .. }
	clocking ${1:name_cb} @(posedge ${2:clock});
	    default input #${3:setup_time} output #${4:hold_time};
	    ${5}
	    // output declarations
	    // input declarations
	endclocking: $1
snippet do  do .. while()
	do begin
	    ${2}
	end while($1);
snippet enum  enum .. { .. }
	typedef enum {${2}
		      } ${1:name_e};
snippet final  final ..
	final begin
	    ${1}
	end
snippet for  for() .. 
	for(${1:int i = 0}; ${2:i < n}; ${3:i++}) begin
	    ${4}
	end
snippet generate  generate..()for .. 
	generate
	    for(${1:genvar i = 0}; ${2:i < n}; ${3:i = i + 1}) begin
	       ${4}
	    end
	endgenerate
snippet foreach  foreach(x[i]) ..
	foreach(${1:x}[i]) begin
	    ${2}
	end
snippet forever  forever .. 
	forever begin
	    ${1}
	end
snippet fork  fork .. join
	fork
	    begin
	        ${1}
	    end
	    begin
	
	    end
	join
snippet fork  fork .. join_any
	fork
	    begin
	        ${1}
	    end
	    begin
	
	    end
	join_any
snippet fork  fork .. join_none
	fork
	    begin
	        ${1}
	    end
	    begin
	
	    end
	join_none
snippet function  function .. endfunction
	function ${1:void} ${2:function_name} ($3);
	    ${4}
	endfunction: $2
snippet cover  covergroup .. endgroup
	covergroup ${1:function_name}_grp;
	\`include($1_coverage)
	endgroup: $1
snippet cg  covergroup .. endgroup
	//covergroup: ${1:function_name}_grp;
	\`include($1_coverage)
	endgroup: $1
snippet cp  coverpoint 
	//coverpoint: ${1:function}_cov
	// signal_a = {intf_fcov.sin_a,intf_fcov.sin_b}
	$1_cov:coverpoint (${3:signal_a or register_a or field_a})\

	    iff(${4:intf_fcov.sinc})\
	    {\
	    bins  bin0  {5'b00000};)\
	    }
snippet cp_a  coverpoint_array
	\`define ${1:FUNCTION1}_COV(idx)\
	//coverpoint_array: ${2:function1}= tolower("$1")
	// signal_a = {intf_fcov.sin_a[idx],intf_fcov.sin_b[idx]}
	$2\`\`idx:coverpoint (${3:signal_a[idx] or register_a[idx] or field_a})\

	    iff($3)\
	    {\
	    bins bin0  {5'b00000};)\
	    bins bin1  {5'b00001};)\
	    }
	\`$1_COV(0)
	\`$1_COV(1)
snippet group_grp  group_covergroup
	covergroup ${1:function_name}_grp; 
	\`include($1_coverage)
	endcovergroup:$1 

snippet if  if() .. 
	if(${1:condition}) begin
	    ${2}
	end
snippet ife  if() .. else
	if(${1:condition}) begin
	    ${2}
	end
	else begin
	    ${3}
	end
snippet initial  initial ..
	initial begin
	    ${1}
	end
snippet interface  interface .. { .. }
	// vmm rule 4-4 -- interfaces shall be packaged into the same files as the
	// transactors that use them
	interface ${1:name_if} (// input wire clk,
			     // input wire reset
			     );
	    timeunit 1ns;
	    timeprecision 100ps;
	
	    ${2}
	    parameter hold_time = 2;     // timeunit is 1ns
	    parameter setup_time = 2;    // change timing values as per requirement
	
	    // Clocking Blocks
	    // just type clocking and tab to invoke snippet
	
	    // Modports
	    // just type modport and tab to invoke snippet





	    //  debug
	    // debug intf
	
	endinterface: $1
snippet modport  modport .. { .. }
	modport ${1:name_mp}
	    (${2}
	     // clocking clocking_cb,
	     // input input_name,
	     // output output_port,
	     // ....
	     );
snippet module  module .. endmodule
	module ${1:module_name} (/*port details*/);
	    ${2}
	endmodule: $1
snippet once  `ifndef XXX; `define XXX; `endif
	\`ifndef ${1:`toupper('_'.substitute(expand('%:t'), '\.', '_', '').'_')`}
	
	\`define $1
	
	${2}
	
	\`endif // Guard
snippet package  package .. endpackage
	// package: ${1:package_name}
	// 
	package $1;
	    ${2}
	endpackage: $1
snippet parameter  parameter .. 
	parameter ${1:param_name} = ${2:param_value};
	${3}
snippet program  program .. { .. }
	program automatic ${1:name};
	    // declarations
	    ${2}
	
	    initial begin
	
	    end
	endprogram: $1
snippet randcase  randcase .. endcase
	randcase;
	    ${1:weight1}:
	        ${3}
	    ${2:weight2}:
	endcase
snippet repeat  repeat(N) ..
	repeat(${1:N}) begin
	    ${2}
	end
snippet struct  struct ... { ... }
	typedef struct {
	    ${2}
	    } ${1:name_s};
snippet task  task .. endtask
	task ${1:task_name} ($3);
	    ${2}
	endtask: $1
snippet union  union ... { ... }
	typedef union {
	    ${2}
	} ${1:name_u};
snippet while  while() ..
	while (${1:condition}) begin
	    ${2}
	end
snippet type  type_id::create( .. )
	type_id::create("${1:name}", this);
snippet typ  UVM Factory
	${1:name} = ${2:class_type}::type_id::create("$1", this);
snippet uvm  UVM Agent
	class ${1:uvc_name}_AgentConfig extends uvm_object;
	   \`uvm_object_utils ($1_AgentConfig)
	   bit hasCoverage = 0;
	   bit isActive    = 1;

	   function new (string name = "$1_AgentConfig");
	      super.new(name);
	   endfunction:new



	endclass:$1_AgentConfig

	class $1_agent extends uvm_agent;

	   \`uvm_component_utils_begin($1_agent)
	      \`uvm_field_enum(uvm_active_passive_enum, is_active, UVM_ALL_ON)
	   \`uvm_component_utils_end
	   ${3}
	   static string MSGID = "/../$1_agent";
	   $1_AgentConfig                cfg;
	   uvm_analysis #($1_transaction) ap;
	   $1_sequencer                  sqr;
	   $1_driver                     drv;
	   $1_monitor                    mon;
	   $1_coverage                   cov;
	   extern function new(string name = "$1_agent", uvm_component parent = null);
	   extern function void build_phase(uvm_phase phase);
	   extern function void connect_phase(uvm_phase phase);
 
	
	endclass: $1_agent
 
	
	   function $1_agent:: new(string name = "$1_agent", uvm_component parent = null);
	      super.new(name, parent);
	      this.cfg = new();
	   endfunction: new
	
	   function void $1_agent::build_phase(uvm_phase phase);
	      super.build_phase(phase);
	      if (!uvm_config_db #($1_AgentConfig)::get(this,"$1_AgentConfig",cfg) begin
	          \`uvm_error({MSGID,"Failed to get agent's config object:$1_AgentConfig"})
	      end
	      if (cfg.isActive == UVM_ACTIVE) begin
		  drv = $1_driver::type_id::create("drv", this);
		  sqr = $1_sequencer::type_id::create("sqr", this);
	      end
	      // Monitor is always present
	      mon = $1_monitor::type_id::create("mon", this);
	      if(cfg.hasCoverage)begin
	          cov =$1_coverage::type_id::create("cov",this);
	      end
 
	   endfunction: build_phase
	
	   function void $1_agent::connect_phase(uvm_phase phase);
	      ap = mon.analysisPort;
	      mon.$1_Vif =cfg.$1_Vif;
	      if (cfg.isActive == UVM_ACTIVE) begin
		  drv.seq_item_port.connect(sequencer.seq_item_export);
		  drv.$1_Vif = cfg.$1_Vif;
	      end
	      if(cfg.hasCoverage)begin
	          m_montor.analysis_port.connect(m_coverage.analysis_export);
	      end

	   endfunction: connect_phase	
	
snippet uvm_agent  UVM Agent
	class ${1:uvc}_agent extends uvm_agent;
	   ${3}
	   uvm_active_passive_enum is_active;
	   $1_sequencer sequencer;
	   $1_driver driver;
	   $1_monitor monitor;
	
	   \`uvm_component_utils_begin($1_agent)
	      \`uvm_field_enum(uvm_active_passive_enum, is_active, UVM_ALL_ON)
	   \`uvm_component_utils_end
	
	   function new(string name, uvm_component parent);
	      super.new(name, parent);
	   endfunction: new
	
	   virtual function void build_phase(uvm_phase phase);
	      super.build_phase(phase);
	      if (is_active == UVM_ACTIVE) begin
		  driver=$1_driver::type_id::create("driver", this);
		  sequencer=$1_sequencer::type_id::create("sequencer", this);
	      end
	      monitor=$1_monitor::type_id::create("monitor", this);
	   endfunction: build_phase
	
	   virtual function void connect_phase(uvm_phase phase);
	      if (is_active == UVM_ACTIVE) begin
		  driver.seq_item_port.connect(sequencer.seq_item_export);
	      end
	   endfunction: connect_phase	

	endclass: ${1:uvc}_agent
snippet uvmagent  UVM Agent
	class ${1:uvc_name}_agent extends uvm_agent;
	   ${3}
	   uvm_active_passive_enum is_active;
	   $1_sequencer sequencer;
	   $1_driver driver;
	   $1_monitor monitor;
	
	   \`uvm_component_utils_begin($1_agent)
	      \`uvm_field_enum(uvm_active_passive_enum, is_active, UVM_ALL_ON)
	   \`uvm_component_utils_end
	
	   function new(string name, uvm_component parent);
	      super.new(name, parent);
	   endfunction: new
	
	   virtual function void build_phase(uvm_phase phase);
	      super.build_phase(uvm_phase phase);
	      if (is_active == UVM_ACTIVE) begin
	   	  driver=$1_driver::type_id::create("driver", this);
		  sequencer=$1_sequencer::type_id::create("sequencer", this);
	      end
	      monitor=$1_monitor::type_id::create("monitor", this);
	   endfunction: build_phase
	
	   virtual function void connect_phase(uvm_phase phase);
	      if (is_active == UVM_ACTIVE) begin
		  driver.seq_item_port.connect(sequencer.seq_item_export);
	      end
	   endfunction: connect_phase
	
	endclass: $1_agent
snippet uvm  UVM Data Item
	class ${1:packet_header} extends uvm_object;
	   rand bit[5:0]  length;
	   rand bit[1:0]  addr;
	   \`uvm_object_utils_begin(${1:packet_header})
	      \`uvm_field_int(addr, UVM_ALL_ON)
	      \`uvm_field_int(length, UVM_ALL_ON)
	   \`uvm_object_utils_end
	endclass:$1
	typedef enum{BAD_PARITY,GOOD_PARITY} parity_e;
	class ${2:uvc_item} extends uvm_sequence_item;
	   ${3}
	   /* AUTO_UVM_VARS */

	   // pkt_header class
	   rand packet_header  header;
	   rand parity_e parity_type;
	   // dynamic array in the ranger[1:63]
	   rand bit [7:0] payload [];
	   // calculated in post randomize()
	   rand bit [7:0] parity;
	   rand int packet_delay;

	   // constraint
	   constraint addr_const{

	   }  

	   // UVM macros for build-in-automation- These declartions enable automation
	   // of the data_item fields and implement create() and get_type_name()
	   \`uvm_object_utils_begin(${2:uvc_item})
	      \`uvm_field_object(header, UVM_ALL_ON)
	      \`uvm_field_enum(parity_type, UVM_ALL_ON)
	      \`uvm_field_int(parity, UVM_ALL_ON)
	      \`uvm_field_array_int(parity_delay, UVM_ALL_ON)
	      \`uvm_field_array_int(payload, UVM_ALL_ON)
	   \`uvm_object_utils_end
	   //  Constructior:new
	   function new(string name="$1");
	      super.new(name);
	      header = packet_header::type_id::create("header");
	   endfunction: new
	
	endclass: $1
snippet uvm_sequence_item  UVM Data Item
	class ${1:packet_header} extends uvm_object;
	   rand bit[5:0]  length;
	   rand bit[1:0]  addr;
	   \`uvm_object_utils_begin(${1:packet_header})
	      \`uvm_field_int(addr, UVM_ALL_ON)
	      \`uvm_field_int(length, UVM_ALL_ON)
	   \`uvm_object_utils_end
	endclass:$1
	typedef enum{BAD_PARITY,GOOD_PARITY} parity_e;
	class ${2:uvc_item} extends uvm_sequence_item;
	   ${3}
	   /* AUTO_UVM_VARS */

	   // pkt_header class
	   rand packet_header  header;
	   rand parity_e parity_type;
	   // dynamic array in the ranger[1:63]
	   rand bit [7:0] payload [];
	   // calculated in post randomize()
	   rand bit [7:0] parity;
	   rand int packet_delay;

	   // constraint
	   constraint addr_const{

	   }  

	   // UVM macros for build-in-automation- These declartions enable automation
	   // of the data_item fields and implement create() and get_type_name()
	   \`uvm_object_utils_begin(${2:uvc_item})
	      \`uvm_field_object(header, UVM_ALL_ON)
	      \`uvm_field_enum(parity_type, UVM_ALL_ON)
	      \`uvm_field_int(parity, UVM_ALL_ON)
	      \`uvm_field_array_int(parity_delay, UVM_ALL_ON)
	      \`uvm_field_array_int(payload, UVM_ALL_ON)
	   \`uvm_object_utils_end
	   //  Constructior:new
	   function new(string name="$1");
	      super.new(name);
	      header = packet_header::type_id::create("header");
	   endfunction: new
	
	endclass: $1
snippet uvm_data  UVM Data Item
	class ${1:packet_header} extends uvm_object;
	   rand bit[5:0]  length;
	   rand bit[1:0]  addr;
	   \`uvm_object_utils_begin(${1:packet_header})
	      \`uvm_field_int(addr, UVM_ALL_ON)
	      \`uvm_field_int(length, UVM_ALL_ON)
	   \`uvm_object_utils_end
	endclass:$1
	typedef enum{BAD_PARITY,GOOD_PARITY} parity_e;
	class ${2:uvc_item} extends uvm_sequence_item;
	   ${3}
	   /* AUTO_UVM_VARS */

	   // pkt_header class
	   rand packet_header  header;
	   rand parity_e parity_type;
	   // dynamic array in the ranger[1:63]
	   rand bit [7:0] payload [];
	   // calculated in post randomize()
	   rand bit [7:0] parity;
	   rand int packet_delay;

	   // constraint
	   constraint addr_const{

	   }  

	   // UVM macros for build-in-automation- These declartions enable automation
	   // of the data_item fields and implement create() and get_type_name()
	   \`uvm_object_utils_begin(${2:uvc_item})
	      \`uvm_field_object(header, UVM_ALL_ON)
	      \`uvm_field_enum(parity_type, UVM_ALL_ON)
	      \`uvm_field_int(parity, UVM_ALL_ON)
	      \`uvm_field_array_int(parity_delay, UVM_ALL_ON)
	      \`uvm_field_array_int(payload, UVM_ALL_ON)
	   \`uvm_object_utils_end
	   //  Constructior:new
	   function new(string name="$1");
	      super.new(name);
	      header = packet_header::type_id::create("header");
	   endfunction: new
	
	endclass: $1
snippet uvm_data_item  UVM Data Item
	class ${1:packet_header} extends uvm_object;
	   rand bit[5:0]  length;
	   rand bit[1:0]  addr;
	   \`uvm_object_utils_begin(${1:packet_header})
	      \`uvm_field_int(addr, UVM_ALL_ON)
	      \`uvm_field_int(length, UVM_ALL_ON)
	   \`uvm_object_utils_end
	endclass:$1
	typedef enum{BAD_PARITY,GOOD_PARITY} parity_e;
	class ${2:uvc_item} extends uvm_sequence_item;
	   ${3}
	   /* AUTO_UVM_VARS */

	   // pkt_header class
	   rand packet_header  header;
	   rand parity_e parity_type;
	   // dynamic array in the ranger[1:63]
	   rand bit [7:0] payload [];
	   // calculated in post randomize()
	   rand bit [7:0] parity;
	   rand int packet_delay;

	   // constraint
	   constraint addr_const{

	   }  

	   // UVM macros for build-in-automation- These declartions enable automation
	   // of the data_item fields and implement create() and get_type_name()
	   \`uvm_object_utils_begin(${2:uvc_item})
	      \`uvm_field_object(header, UVM_ALL_ON)
	      \`uvm_field_enum(parity_type, UVM_ALL_ON)
	      \`uvm_field_int(parity, UVM_ALL_ON)
	      \`uvm_field_array_int(parity_delay, UVM_ALL_ON)
	      \`uvm_field_array_int(payload, UVM_ALL_ON)
	   \`uvm_object_utils_end
	   //  Constructior:new
	   function new(string name="$1");
	      super.new(name);
	      header = packet_header::type_id::create("header");
	   endfunction: new
	
	endclass: $1
snippet uvm_item  UVM Data Item
	class ${1:ovc_item} extends uvm_sequence_item;
	   ${2}
	   /* AUTO_UVM_VARS */
	   typedef enum{cfg_0,cfg_1,cfg_2} Cfg;

	   rand Cfg  myCfg;
	   rand bit  info;
	   rand bit [3:0] addr;
	   rand bit [5:0] length;
	   rand bit [7:0] payload [];
	   // Customization of domain for static arrays
	   rand bit [7:0] size [8];
	   constraint addr_const{
	    addr = payload.size + info *4;

	   }
	   constraint payload_size_const{
	    addr > payload.size() ;
	    foreach(size[i]{
	    size[i] < payload.size()} ;

	   }   
	   \`uvm_object_utils_begin($1)
	      \`uvm_field_enum(myCfg, UVM_ALL_ON)
	      \`uvm_field_bool(info, UVM_ALL_ON)
	      \`uvm_field_int(addr, UVM_ALL_ON)
	      \`uvm_field_int(length, UVM_ALL_ON)
	      \`uvm_field_array_int(payload, UVM_ALL_ON)
	      \`uvm_field_sarray_int(size, UVM_ALL_ON)
	   \`uvm_object_utils_end
	   //  Constructior:new
	   function new(string name="$1");
	      super.new(name);
	   endfunction: new
	
	endclass: $1
snippet uvm  UVM Driver
	class ${1:ovc_name}_driver extends uvm_driver #(${2:ovc_item});
	   ${4}
	   string tID;
	   virtual interface ${3:ovc_if} vif;
	   $2 item;

	   \`uvm_component_utils_begin($1_driver)
	      \`uvm_field_object(item, UVM_ALL_ON)
	   \`uvm_component_utils_end
	
	   function new(string name, uvm_component parent);
	      super.new(name, parent);
	      tID = get_type_name();
	      tID = tID.toupper();
	   endfunction: new
	
	   virtual function void build_phase(uvm_phase phase);
	   super.build_phase(phase);
	   if(!uvm_config_db#(string)::get(this, "", "${3:ovc_if}", ${3:ovc_if}) begin
		   `uvm_fatal("NOSTRING", {"Need interface name for:",get_full_name(),"${3:ovc_if})"})
	   end
	   if(!uvm_config_db#(virtual ${3:ovc_if})::get(this, "",${3:ovc_if}, vif)) begin
	           `uvm_fatal("NOVIF", {"virtual interface must be set for: ", get_full_name(), ".vif"})
	   end
	   endfunction : build_phase

	   virtual task run_phase(uvm_phase phase);
	       fork
	           reset();
	           get_and_drive();
	       join_none
	   endtask : run_phase

	   virtual task reset();

	   endtask : reset
	
	   task get_and_drive();
	      forever
		begin
		   // wait(vif.reset==0);  // block until reset released
		   seq_item_port.get_next_item(item);
		   send_to_dut(item);
		   seq_item_port.item_done();
		end
	   endtask: get_and_drive
	
	   task send_to_dut(input $2 item);
	      uvm_report_info(tID, $psprintf("%s : item sent is %0s",
					     tID, item.sprint()), UVM_FULL);
	      // Send data to DUT (BFM - fill in your BFM code here)
	      #10 ;
	      #10 ;
	   endtask: send_to_dut
	
	   virtual function void report();
	      // fill in any reporting code if needed
	      logic dummy;
	   endfunction: report
	endclass: $1_driver
snippet uvm_driver  UVM Driver
	class ${1:ovc_name}_driver extends uvm_driver #(${2:ovc_item});
	   ${4}
	   string tID;
	   virtual interface ${3:ovc_if} vif;
	   $2 item;
	
	   function new(string name, uvm_component parent);
	      super.new(name, parent);
	      tID = get_type_name();
	      tID = tID.toupper();
	   endfunction: new
	
	   \`uvm_component_utils_begin($1_driver)
	      \`uvm_field_object(item, UVM_ALL_ON)
	   \`uvm_component_utils_end
	
	   task get_and_drive();
	      forever
		begin
		   // wait(vif.reset==0);  // block until reset released
		   seq_item_port.get_next_item(item);
		   send_to_dut(item);
		   seq_item_port.item_done();
		end
	   endtask: get_and_drive
	
	   task send_to_dut(input $2 item);
	      uvm_report_info(tID, $psprintf("%s : item sent is %0s",
					     tID, item.sprint()), UVM_FULL);
	      // Send data to DUT (BFM - fill in your BFM code here)
	      #10 ;
	      #10 ;
	   endtask: send_to_dut
	
	   task reset_dut();
	      // fill in any reset code here
	   endtask: reset_dut
	
	   task run();
	      uvm_report_info(tID, $psprintf(" %s : running", tID), UVM_MEDIUM);
	      // reset_dut(); // fill in 'reset_dut()' if needed
	      get_and_drive();
	   endtask: run
	
	   virtual function void report();
	      // fill in any reporting code if needed
	      logic dummy;
	   endfunction: report
	endclass: $1_driver
snippet uvmdriver  UVM Driver
	class ${1:ovc_name}_driver extends uvm_driver #(${2:ovc_item});
	   ${4}
	   string tID;
	   virtual interface ${3:ovc_if} vif;
	   $2 item;
	
	   function new(string name, uvm_component parent);
	      super.new(name, parent);
	      tID = get_type_name();
	      tID = tID.toupper();
	   endfunction: new
	
	   \`uvm_component_utils_begin($1_driver)
	      \`uvm_field_object(item, UVM_ALL_ON)
	   \`uvm_component_utils_end
	
	   task get_and_drive();
	      forever
		begin
		   // wait(vif.reset==0);  // block until reset released
		   seq_item_port.get_next_item(item);
		   send_to_dut(item);
		   seq_item_port.item_done();
		end
	   endtask: get_and_drive
	
	   task send_to_dut(input $2 item);
	      uvm_report_info(tID, $psprintf("%s : item sent is %0s",
					     tID, item.sprint()), UVM_FULL);
	      // Send data to DUT (BFM - fill in your BFM code here)
	      #10 ;
	      #10 ;
	   endtask: send_to_dut
	
	   task reset_dut();
	      // fill in any reset code here
	   endtask: reset_dut
	
	   task run();
	      uvm_report_info(tID, $psprintf(" %s : running", tID), UVM_MEDIUM);
	      // reset_dut(); // fill in 'reset_dut()' if needed
	      get_and_drive();
	   endtask: run
	
	   virtual function void report();
	      // fill in any reporting code if needed
	      logic dummy;
	   endfunction: report
	endclass: $1_driver
snippet uvm  UVM Env
	class ${1:ovc_name}_env extends uvm_env;
	   ${2}
	   $1_agent agent0;
	   \`uvm_component_utils($1_env)
	
	   function new(string name, uvm_component parent);
	      super.new(name, parent);
	   endfunction: new
	
	   virtual function void build();
	      super.build();
	      agent0 = $1_agent::type_id::create("agent0", this);
	   endfunction: build
	
	endclass: $1_env
snippet uvm_env  UVM Env
	class ${1:ovc_name}_env extends uvm_env;
	   ${2}
	   $1_agent agent0;
	   \`uvm_component_utils($1_env)
	
	   function new(string name, uvm_component parent);
	      super.new(name, parent);
	   endfunction: new
	
	   virtual function void build();
	      super.build();
	      agent0 = $1_agent::type_id::create("agent0", this);
	   endfunction: build
	
	endclass: $1_env
snippet uvmenv  UVM Env
	class ${1:ovc_name}_env extends uvm_env;
	   ${2}
	   $1_agent agent0;
	   \`uvm_component_utils($1_env)
	
	   function new(string name, uvm_component parent);
	      super.new(name, parent);
	   endfunction: new
	
	   virtual function void build();
	      super.build();
	      agent0 = $1_agent::type_id::create("agent0", this);
	   endfunction: build
	
	endclass: $1_env
snippet uvm  UVM Interface
	interface $1(input logic clock, input logic reset);
	
	   // ToDo: Declare the interface signals corresponding to the ports
	   ${2}
	   wire [7:0] sync_tx;
	   wire [7:0] sync_rx;
	
	   logic async_sig;
	   
	   // ToDo: Define clocking blocks
	   // -- use the 'clocking' snippet
	   
	   // ToDo: Define a modport for each interface perspective
	   // -- use the 'modport' snippet
	
	endinterface: $1
snippet interface  UVM Interface
	interface $1(input logic clock, input logic reset);
	
	   // ToDo: Declare the interface signals corresponding to the ports
	   ${2}
	   wire [7:0] sync_tx;
	   wire [7:0] sync_rx;
	
	   logic async_sig;
	   
	   // ToDo: Define clocking blocks
	   // -- use the 'clocking' snippet
	   
	   // ToDo: Define a modport for each interface perspective
	   // -- use the 'modport' snippet
	
	endinterface: $1
snippet uvm  UVM Monitor
	class ${1:ovc_name}_monitor extends uvm_monitor;
	   ${4}
	   string tID;
	   virtual interface ${2:ovc_if} vif;
	   ${3:ovc_item} trans;
	   event e_trans_collected; // event to signal transaction collected
	   // TLM port for scoreboard communication
	   //  (implement scoreboard write method if needed)
	   uvm_analysis_port #($3) sb_post;
	
	   \`uvm_component_utils_begin($1_monitor)
	      \`uvm_field_object(trans, UVM_ALL_ON)
	   \`uvm_component_utils_end
	
	   task collect_data();
	      forever begin
		 //put code to collect bus transactions here
		 #10 ;
	
		 #10 ;
	
		 ->e_trans_collected; //signal transaction collection complete
		 //post good transactions to scoreboard if enabled
		 if (sb_post.size() > 0)
		   sb_post.write(trans);
	      end;
	   endtask: collect_data
	
	   // to FIX stuff for covergroup
	   /*
	    //shell code for covergroup
	    covergroup cov_trans @ e_trans_collected;
	    cg1: coverpoint trans..$fields[2].
	    { bins MIN[]     = {0};
	    bins MAX[]     = {63};
	    }
	endgroup
	    */
	
	   task run();
	      \`message(UVM_MEDIUM, ("$1_monitor: running"))
	      uvm_report_info(tID, $psprintf("%s: running", tID), UVM_MEDIUM);
	      collect_data();
	   endtask: run
	
	   virtual function void report();
	      //fill in any reporting code if needed
	      logic dummy;
	   endfunction: report
	
	   //new() function needs to be listed last so other items defined
	   function new(string name, uvm_component parent);
	      super.new(name, parent);
	      tID = get_type_name();
	      tID = tID.toupper();
	      // to FIX stuff for covergroup
	      /*
	       cov_trans = new();
	       cov_trans.set_inst_name({get_full_name(), ".cov_trans"});
	       */
	      trans = new();
	      sb_post = new("sb_post", this);
	   endfunction: new
	
	endclass: $1_monitor
snippet uvm_monitor  UVM Monitor
	class ${1:ovc_name}_monitor extends uvm_monitor;
	   ${4}
	   string tID;
	   virtual interface ${2:ovc_if} vif;
	   ${3:ovc_item} trans;
	   event e_trans_collected; // event to signal transaction collected
	   // TLM port for scoreboard communication
	   //  (implement scoreboard write method if needed)
	   uvm_analysis_port #($3) sb_post;
	
	   \`uvm_component_utils_begin($1_monitor)
	      \`uvm_field_object(trans, UVM_ALL_ON)
	   \`uvm_component_utils_end
	
	   task collect_data();
	      forever begin
		 //put code to collect bus transactions here
		 #10 ;
	
		 #10 ;
	
		 ->e_trans_collected; //signal transaction collection complete
		 //post good transactions to scoreboard if enabled
		 if (sb_post.size() > 0)
		   sb_post.write(trans);
	      end;
	   endtask: collect_data
	
	   // to FIX stuff for covergroup
	   /*
	    //shell code for covergroup
	    covergroup cov_trans @ e_trans_collected;
	    cg1: coverpoint trans..$fields[2].
	    { bins MIN[]     = {0};
	    bins MAX[]     = {63};
	    }
	endgroup
	    */
	
	   task run();
	      \`message(UVM_MEDIUM, ("$1_monitor: running"))
	      uvm_report_info(tID, $psprintf("%s: running", tID), UVM_MEDIUM);
	      collect_data();
	   endtask: run
	
	   virtual function void report();
	      //fill in any reporting code if needed
	      logic dummy;
	   endfunction: report
	
	   //new() function needs to be listed last so other items defined
	   function new(string name, uvm_component parent);
	      super.new(name, parent);
	      tID = get_type_name();
	      tID = tID.toupper();
	      // to FIX stuff for covergroup
	      /*
	       cov_trans = new();
	       cov_trans.set_inst_name({get_full_name(), ".cov_trans"});
	       */
	      trans = new();
	      sb_post = new("sb_post", this);
	   endfunction: new
	
	endclass: $1_monitor
snippet uvm_mon  UVM Monitor
	class ${1:ovc_name}_monitor extends uvm_monitor;
	   ${4}
	   string tID;
	   virtual interface ${2:ovc_if} vif;
	   ${3:ovc_item} trans;
	   event e_trans_collected; // event to signal transaction collected
	   // TLM port for scoreboard communication
	   //  (implement scoreboard write method if needed)
	   uvm_analysis_port #($3) sb_post;
	
	   \`uvm_component_utils_begin($1_monitor)
	      \`uvm_field_object(trans, UVM_ALL_ON)
	   \`uvm_component_utils_end
	
	   task collect_data();
	      forever begin
		 //put code to collect bus transactions here
		 #10 ;
	
		 #10 ;
	
		 ->e_trans_collected; //signal transaction collection complete
		 //post good transactions to scoreboard if enabled
		 if (sb_post.size() > 0)
		   sb_post.write(trans);
	      end;
	   endtask: collect_data
	
	   // to FIX stuff for covergroup
	   /*
	    //shell code for covergroup
	    covergroup cov_trans @ e_trans_collected;
	    cg1: coverpoint trans..$fields[2].
	    { bins MIN[]     = {0};
	    bins MAX[]     = {63};
	    }
	endgroup
	    */
	
	   task run();
	      \`message(UVM_MEDIUM, ("$1_monitor: running"))
	      uvm_report_info(tID, $psprintf("%s: running", tID), UVM_MEDIUM);
	      collect_data();
	   endtask: run
	
	   virtual function void report();
	      //fill in any reporting code if needed
	      logic dummy;
	   endfunction: report
	
	   //new() function needs to be listed last so other items defined
	   function new(string name, uvm_component parent);
	      super.new(name, parent);
	      tID = get_type_name();
	      tID = tID.toupper();
	      // to FIX stuff for covergroup
	      /*
	       cov_trans = new();
	       cov_trans.set_inst_name({get_full_name(), ".cov_trans"});
	       */
	      trans = new();
	      sb_post = new("sb_post", this);
	   endfunction: new
	
	endclass: $1_monitor

snippet uvmmon  UVM Monitor
	class ${1:ovc_name}_monitor extends uvm_monitor;
	   ${4}
	   string tID;
	   virtual interface ${2:ovc_if} vif;
	   ${3:ovc_item} trans;

	   event e_trans_collected; // event to signal transaction collected
	   // TLM port for scoreboard communication
	   //  (implement scoreboard write method if needed)
	   uvm_analysis_port #($3) sb_post;
	
	   \`uvm_component_utils_begin($1_monitor)
	      \`uvm_field_object(trans, UVM_ALL_ON)
	   \`uvm_component_utils_end
	
	   task collect_data();
	      forever begin
		 //put code to collect bus transactions here
		 #10 ;
	
		 #10 ;
	
		 ->e_trans_collected; //signal transaction collection complete
		 //post good transactions to scoreboard if enabled
		 if (sb_post.size() > 0)
		   sb_post.write(trans);
	      end;
	   endtask: collect_data
	
	   // to FIX stuff for covergroup
	   /*
	    //shell code for covergroup
	    covergroup cov_trans @ e_trans_collected;
	    cg1: coverpoint trans..$fields[2].
	    { bins MIN[]     = {0};
	    bins MAX[]     = {63};
	    }
	endgroup
	    */
	
	   task run();
	      \`message(UVM_MEDIUM, ("$1_monitor: running"))
	      uvm_report_info(tID, $psprintf("%s: running", tID), UVM_MEDIUM);
	      collect_data();
	   endtask: run
	
	   virtual function void report();
	      //fill in any reporting code if needed
	      logic dummy;
	   endfunction: report
	
	   //new() function needs to be listed last so other items defined
	   function new(string name, uvm_component parent);
	      super.new(name, parent);
	      tID = get_type_name();
	      tID = tID.toupper();
	      // to FIX stuff for covergroup
	      /*
	       cov_trans = new();
	       cov_trans.set_inst_name({get_full_name(), ".cov_trans"});
	       */
	      trans = new();
	      sb_post = new("sb_post", this);
	   endfunction: new
	
	endclass: $1_monitor
snippet uvmmonitor  UVM Monitor
	class ${1:ovc_name}_monitor extends uvm_monitor;
	   ${4}
	   string tID;
	   virtual interface ${2:ovc_if} vif;
	   ${3:ovc_item} trans;
	   event e_trans_collected; // event to signal transaction collected
	   // TLM port for scoreboard communication
	   //  (implement scoreboard write method if needed)
	   uvm_analysis_port #($3) sb_post;
	
	   \`uvm_component_utils_begin($1_monitor)
	      \`uvm_field_object(trans, UVM_ALL_ON)
	   \`uvm_component_utils_end
	
	   task collect_data();
	      forever begin
		 //put code to collect bus transactions here
		 #10 ;
	
		 #10 ;
	
		 ->e_trans_collected; //signal transaction collection complete
		 //post good transactions to scoreboard if enabled
		 if (sb_post.size() > 0)
		   sb_post.write(trans);
	      end;
	   endtask: collect_data
	
	   // to FIX stuff for covergroup
	   /*
	    //shell code for covergroup
	    covergroup cov_trans @ e_trans_collected;
	    cg1: coverpoint trans..$fields[2].
	    { bins MIN[]     = {0};
	    bins MAX[]     = {63};
	    }
	endgroup
	    */
	
	   task run();
	      \`message(UVM_MEDIUM, ("$1_monitor: running"))
	      uvm_report_info(tID, $psprintf("%s: running", tID), UVM_MEDIUM);
	      collect_data();
	   endtask: run
	
	   virtual function void report();
	      //fill in any reporting code if needed
	      logic dummy;
	   endfunction: report
	
	   //new() function needs to be listed last so other items defined
	   function new(string name, uvm_component parent);
	      super.new(name, parent);
	      tID = get_type_name();
	      tID = tID.toupper();
	      // to FIX stuff for covergroup
	      /*
	       cov_trans = new();
	       cov_trans.set_inst_name({get_full_name(), ".cov_trans"});
	       */
	      trans = new();
	      sb_post = new("sb_post", this);
	   endfunction: new
	
	endclass: $1_monitor
snippet uvm  UVM Seq Lib
	class ${1:ovc_name}_seq1 extends uvm_sequence #(${2:ovc_item});
	   ${3}
	   string tID;
	   \`uvm_sequence_utils($1_seq1, $1_sequencer)
	   // $2 trans;
	   // "req" built-in uvm_sequence class member for sequence_item
	   rand int delay1;
	   rand int delay2;
	   constraint d1 {delay1 > 55; delay1 < 125;}
	   constraint d2 {delay2 > 25; delay2 < 45;}
	
	   function new(string name = "$1_seq1");
	      super.new(name);
	      tID = get_type_name();
	      tID = tID.toupper();
	   endfunction: new
	
	   task body();
	      \`message(UVM_LOW, ("RUNNING sequence: %s", get_name()))
	      uvm_report_info(tID, $psprintf("%s: sequence Running", tID), UVM_LOW);
	      // not the best way to print, just to confirm randomization
	      \`message(UVM_LOW, ("delay1=%0d, delay2=%0d", delay1, delay2))
	      uvm_report_info(tID, $psprintf("%s: delay1=%0d, delay2=%0d",
					     tID, delay1, delay2), UVM_MEDIUM);
	      #delay1
		// dummy delay to illustrate a sequence rand variable
	      \`uvm_do(req) // this line sends the transaction
	      #delay1
		// get_response(rsp); // get response if implemented
	      \`uvm_do(req) // this line sends the transaction
	      #delay1
		// get_response(rsp); // get response if implemented
	      \`uvm_do(req) // this line sends the transaction
	      #delay2
		// get_response(rsp); // get response if implemented
	      \`message(UVM_LOW, ("sequence: %s complete", get_name()))
	      uvm_report_info(tID, $psprintf("sequence: %s complete", tID), UVM_LOW);
	   endtask: body
	
	endclass: $1_seq1
	
	//additional sequences can be included in this file
snippet uvm_seq_lib  UVM Seq Lib
	class ${1:ovc_name}_seq1 extends uvm_sequence #(${2:ovc_item});
	   ${3}
	   string tID;
	   \`uvm_sequence_utils($1_seq1, $1_sequencer)
	   // $2 trans;
	   // "req" built-in uvm_sequence class member for sequence_item
	   rand int delay1;
	   rand int delay2;
	   constraint d1 {delay1 > 55; delay1 < 125;}
	   constraint d2 {delay2 > 25; delay2 < 45;}
	
	   function new(string name = "$1_seq1");
	      super.new(name);
	      tID = get_type_name();
	      tID = tID.toupper();
	   endfunction: new
	
	   task body();
	      \`message(UVM_LOW, ("RUNNING sequence: %s", get_name()))
	      uvm_report_info(tID, $psprintf("%s: sequence Running", tID), UVM_LOW);
	      // not the best way to print, just to confirm randomization
	      \`message(UVM_LOW, ("delay1=%0d, delay2=%0d", delay1, delay2))
	      uvm_report_info(tID, $psprintf("%s: delay1=%0d, delay2=%0d",
					     tID, delay1, delay2), UVM_MEDIUM);
	      #delay1
		// dummy delay to illustrate a sequence rand variable
	      \`uvm_do(req) // this line sends the transaction
	      #delay1
		// get_response(rsp); // get response if implemented
	      \`uvm_do(req) // this line sends the transaction
	      #delay1
		// get_response(rsp); // get response if implemented
	      \`uvm_do(req) // this line sends the transaction
	      #delay2
		// get_response(rsp); // get response if implemented
	      \`message(UVM_LOW, ("sequence: %s complete", get_name()))
	      uvm_report_info(tID, $psprintf("sequence: %s complete", tID), UVM_LOW);
	   endtask: body
	
	endclass: $1_seq1
	
	//additional sequences can be included in this file
snippet uvm_seqlib  UVM Seq Lib
	class ${1:ovc_name}_seq1 extends uvm_sequence #(${2:ovc_item});
	   ${3}
	   string tID;
	   \`uvm_sequence_utils($1_seq1, $1_sequencer)
	   // $2 trans;
	   // "req" built-in uvm_sequence class member for sequence_item
	   rand int delay1;
	   rand int delay2;
	   constraint d1 {delay1 > 55; delay1 < 125;}
	   constraint d2 {delay2 > 25; delay2 < 45;}
	
	   function new(string name = "$1_seq1");
	      super.new(name);
	      tID = get_type_name();
	      tID = tID.toupper();
	   endfunction: new
	
	   task body();
	      \`message(UVM_LOW, ("RUNNING sequence: %s", get_name()))
	      uvm_report_info(tID, $psprintf("%s: sequence Running", tID), UVM_LOW);
	      // not the best way to print, just to confirm randomization
	      \`message(UVM_LOW, ("delay1=%0d, delay2=%0d", delay1, delay2))
	      uvm_report_info(tID, $psprintf("%s: delay1=%0d, delay2=%0d",
					     tID, delay1, delay2), UVM_MEDIUM);
	      #delay1
		// dummy delay to illustrate a sequence rand variable
	      \`uvm_do(req) // this line sends the transaction
	      #delay1
		// get_response(rsp); // get response if implemented
	      \`uvm_do(req) // this line sends the transaction
	      #delay1
		// get_response(rsp); // get response if implemented
	      \`uvm_do(req) // this line sends the transaction
	      #delay2
		// get_response(rsp); // get response if implemented
	      \`message(UVM_LOW, ("sequence: %s complete", get_name()))
	      uvm_report_info(tID, $psprintf("sequence: %s complete", tID), UVM_LOW);
	   endtask: body
	
	endclass: $1_seq1
	
	//additional sequences can be included in this file
snippet uvmseqlib  UVM Seq Lib
	class ${1:ovc_name}_seq1 extends uvm_sequence #(${2:ovc_item});
	   ${3}
	   string tID;
	   \`uvm_sequence_utils($1_seq1, $1_sequencer)
	   // $2 trans;
	   // "req" built-in uvm_sequence class member for sequence_item
	   rand int delay1;
	   rand int delay2;
	   constraint d1 {delay1 > 55; delay1 < 125;}
	   constraint d2 {delay2 > 25; delay2 < 45;}
	
	   function new(string name = "$1_seq1");
	      super.new(name);
	      tID = get_type_name();
	      tID = tID.toupper();
	   endfunction: new
	
	   task body();
	      \`message(UVM_LOW, ("RUNNING sequence: %s", get_name()))
	      uvm_report_info(tID, $psprintf("%s: sequence Running", tID), UVM_LOW);
	      // not the best way to print, just to confirm randomization
	      \`message(UVM_LOW, ("delay1=%0d, delay2=%0d", delay1, delay2))
	      uvm_report_info(tID, $psprintf("%s: delay1=%0d, delay2=%0d",
					     tID, delay1, delay2), UVM_MEDIUM);
	      #delay1
		// dummy delay to illustrate a sequence rand variable
	      \`uvm_do(req) // this line sends the transaction
	      #delay1
		// get_response(rsp); // get response if implemented
	      \`uvm_do(req) // this line sends the transaction
	      #delay1
		// get_response(rsp); // get response if implemented
	      \`uvm_do(req) // this line sends the transaction
	      #delay2
		// get_response(rsp); // get response if implemented
	      \`message(UVM_LOW, ("sequence: %s complete", get_name()))
	      uvm_report_info(tID, $psprintf("sequence: %s complete", tID), UVM_LOW);
	   endtask: body
	
	endclass: $1_seq1
	
	//additional sequences can be included in this file
snippet uvm  UVM Sequencer
	class ${1:ovc_name}_sequencer extends uvm_sequencer #(${2:ovc_item});
	   ${3}
	   \`uvm_sequencer_utils($1_sequencer)
	
	   function new(string name, uvm_component parent);
	      super.new(name, parent);
	      \`uvm_update_sequence_lib_and_item($2)
	   endfunction: new
	
	endclass: $1_sequencer
snippet uvm_sequencer  UVM Sequencer
	class ${1:ovc_name}_sequencer extends uvm_sequencer #(${2:ovc_item});
	   ${3}
	   \`uvm_sequencer_utils($1_sequencer)
	
	   function new(string name, uvm_component parent);
	      super.new(name, parent);
	      \`uvm_update_sequence_lib_and_item($2)
	   endfunction: new
	
	endclass: $1_sequencer
snippet uvmsequencer  UVM Sequencer
	class ${1:ovc_name}_sequencer extends uvm_sequencer #(${2:ovc_item});
	   ${3}
	   \`uvm_sequencer_utils($1_sequencer)
	
	   function new(string name, uvm_component parent);
	      super.new(name, parent);
	      \`uvm_update_sequence_lib_and_item($2)
	   endfunction: new
	
	endclass: $1_sequencer
snippet uvm  UVM Sve
	class sve extends uvm_env;
	   ${2}
	   ${1:ovc_name}_env env0;
	   \`uvm_component_utils(sve)
	
	   function new(string name, uvm_component parent);
	      super.new(name, parent);
	   endfunction: new
	
	   virtual function void build_phase(uvm_phase phase);
	      super.build_phase(phase);
	      env0 = $1_env::type_id::create("env0", this);
	   endfunction: build_phase
	
	endclass: sve
snippet uvm_sve  UVM Sve
	class sve extends uvm_env;
	   ${2}
	   ${1:ovc_name}_env env0;
	   \`uvm_component_utils(sve)
	
	   function new(string name, uvm_component parent);
	      super.new(name, parent);
	   endfunction: new
	
	   virtual function void build_phase(uvm_phase phase);
	      super.build_phase(phase);
	      env0 = $1_env::type_id::create("env0", this);
	   endfunction: build_phase
	
	endclass: sve
snippet uvmsve  UVM Sve
	class sve extends uvm_env;
	   ${2}
	   ${1:ovc_name}_env env0;
	   \`uvm_component_utils(sve)
	
	   function new(string name, uvm_component parent);
	      super.new(name, parent);
	   endfunction: new
	
	   virtual function void build_phase(uvm_phase phase);
	      super.build_phase(phase);
	      env0 = $1_env::type_id::create("env0", this);
	   endfunction: build_phase
	
	endclass: sve
snippet uvm  UVM Test
	class test1 extends uvm_test;
	   ${2}
	   sve sve0;
	   \`uvm_component_utils(test1)
	
	   function new(string name, uvm_component parent);
	      super.new(name, parent);
	   endfunction: new

	   virtual task run_phase(uvm_phase phase);
	      random_sequence seq;
	      super.run_phase(phase);

	      phase.raise_objection(this);
	      seq = random_sequence::type_id::create("seq");  
	      seq.start(env.agent.seqr);
	      phase.drop_objection(this); 
	   endfunction: run_phase

	endclass: test1
snippet uvm_test  UVM Test
	class test1 extends uvm_test;
	   ${2}
	   sve sve0;
	   \`uvm_component_utils(test1)
	
	   function new(string name, uvm_component parent);
	      super.new(name, parent);
	   endfunction: new

	   virtual task run_phase(uvm_phase phase);
	      random_sequence seq;
	      super.run_phase(phase);

	      phase.raise_objection(this);
	      seq = random_sequence::type_id::create("seq");  
	      seq.start(env.agent.seqr);
	      phase.drop_objection(this); 
	   endfunction: run_phase

	endclass: test1
snippet uvmtest  UVM Test
	class test1 extends uvm_test;
	   ${2}
	   sve sve0;
	   \`uvm_component_utils(test1)
	
	   function new(string name, uvm_component parent);
	      super.new(name, parent);
	   endfunction: new

	   virtual task run_phase(uvm_phase phase);
	      random_sequence seq;
	      super.run_phase(phase);

	      phase.raise_objection(this);
	      seq = random_sequence::type_id::create("seq");  
	      seq.start(env.agent.seqr);
	      phase.drop_objection(this); 
	   endfunction: run_phase

	endclass: test1
snippet uvm  UVM Top
	\`include "uvm.svh"
	module ${1:uvc}_top();
	   ${0}
	   import uvm_pkg::*;
	   import ${2:uvc}_test_pkg::*;

	   // Clock generation

	   localparam PERIOD = ${3:10} ns;

	   bit ${4:clock} = 0;
	   bit ${5:reset} ;
	   always #(PERIOD/2)  ${6:clock} = ~${7:clock};

	   initial begin
		${8:clock} = 0;
		${5:reset} = 1; // active high reset for this example
		#75 ${5:reset} = 0;
	     end
	   // instantiate uvc interface	
	   ${1:uvc}_interface ${1:uvc}_intf($4, $5);
	   ${1:uvc}_fcov_interface ${1:uvc}_fcov_intf($4, $5);
	   initial begin
	      uvm_config_db#(virtual ${1:uvc}_interface)::set(uvm_root::get(),"xx.drv","${1:uvc}_intf",${1:uvc}_intf);
	      uvm_config_db#(virtual ${1:uvc}_interface)::set(uvm_root::get(),"xxx.mon","${1:uvc}_intf",${1:uvc}_intf);
	      uvm_config_db#(virtual ${1:uvc}_interface)::set(uvm_root::get(),"uvm_test_top.xx.rm","intf",${1:uvc}_intf);
	      uvm_config_db#(virtual ${1:uvc}_interface)::set(uvm_root::get(),"","${1:uvc}_intf",${1:uvc}_intf);
	      uvm_config_db#(virtual ${1:uvc}_fcov_interface)::set(uvm_root::get(),"uvm_test_top.xx.${1:uvc}_cov","${1:uvc}_fcov_intf",${1:uvc}_fcov_intf);
	   end
	   // link DUT and TB
	   ${1:UVC}_top dut(.clk(${1:uvc}_intf)),
	   )

	   initial begin
		run_test();
	   end
	
	endmodule: $1_top
snippet uvm_top  UVM Top
	\`include "uvm.svh"
	module ${1:uvc}_top();
	   ${0}
	   import uvm_pkg::*;
	   import ${2:uvc}_test_pkg::*;

	   // Clock generation

	   localparam PERIOD = ${3:10} ns;

	   bit ${4:clock} = 0;
	   bit ${5:reset} ;
	   always #(PERIOD/2)  ${6:clock} = ~${7:clock};

	   initial begin
		${8:clock} = 0;
		${5:reset} = 1; // active high reset for this example
		#75 ${5:reset} = 0;
	   end
	   // instantiate uvc interface	
	   ${1:uvc}_interface ${1:uvc}_intf($4, $5);
	   ${1:uvc}_fcov_interface ${1:uvc}_fcov_intf($4, $5);
	   initial begin
	      uvm_config_db#(virtual ${1:uvc}_interface)::set(uvm_root::get(),"xx.drv","${1:uvc}_intf",${1:uvc}_intf);
	      uvm_config_db#(virtual ${1:uvc}_interface)::set(uvm_root::get(),"xxx.mon","${1:uvc}_intf",${1:uvc}_intf);
	      uvm_config_db#(virtual ${1:uvc}_interface)::set(uvm_root::get(),"uvm_test_top.xx.rm","intf",${1:uvc}_intf);
	      uvm_config_db#(virtual ${1:uvc}_interface)::set(uvm_root::get(),"","${1:uvc}_intf",${1:uvc}_intf);
	      uvm_config_db#(virtual ${1:uvc}_fcov_interface)::set(uvm_root::get(),"uvm_test_top.xx.${1:uvc}_cov","${1:uvc}_fcov_intf",${1:uvc}_fcov_intf);
	   end
	   initial begin
		run_test();
	   end
	
	endmodule: $1_top
snippet uvmtop  UVM Top
	\`include "uvm.svh"
	module ${1:uvc}_top();
	   ${0}
	   import uvm_pkg::*;
	   import ${2:uvc}_test_pkg::*;

	   // Clock generation

	   localparam PERIOD = ${3:10} ns;

	   bit ${4:clock} = 0;
	   bit ${5:reset} ;
	   always #(PERIOD/2)  ${6:clock} = ~${7:clock};

	   initial begin
		${8:clock} = 0;
		${5:reset} = 1; // active high reset for this example
		#75 ${5:reset} = 0;
	     end
	   // instantiate uvc interface	
	   ${1:uvc}_interface ${1:uvc}_intf($4, $5);
	   ${1:uvc}_fcov_interface ${1:uvc}_fcov_intf($4, $5);
	   initial begin
	      uvm_config_db#(virtual ${1:uvc}_interface)::set(uvm_root::get(),"xx.drv","${1:uvc}_intf",${1:uvc}_intf);
	      uvm_config_db#(virtual ${1:uvc}_interface)::set(uvm_root::get(),"xxx.mon","${1:uvc}_intf",${1:uvc}_intf);
	      uvm_config_db#(virtual ${1:uvc}_interface)::set(uvm_root::get(),"uvm_test_top.xx.rm","intf",${1:uvc}_intf);
	      uvm_config_db#(virtual ${1:uvc}_interface)::set(uvm_root::get(),"","${1:uvc}_intf",${1:uvc}_intf);
	      uvm_config_db#(virtual ${1:uvc}_fcov_interface)::set(uvm_root::get(),"uvm_test_top.xx.${1:uvc}_cov","${1:uvc}_fcov_intf",${1:uvc}_fcov_intf);
	   end
	   initial begin
		run_test();
	   end
	
	endmodule: $1_top

snippet uvm_error uvm_error

	\`uvm_error(${1:get_full_name(),"message"})

snippet uvm_fatal uvm_fatal

	\`uvm_fatal(${1:get_full_name(),"message"})

snippet uvm_info uvm_info

	\`uvm_info(${1:get_full_name(),"message"},UVM_NONE)

snippet uvm_object_utils uvm_object_utils 

	\`uvm_object_utils(${1:class_name})

snippet coverage function coverage
	\`include "group_coverage.sv"
	class ${1:uvc}_coverage extends uvm_component;
	virtual ${1:uvc}_cov_intf cov_vif;
	bit     has_coverage = 1;
	\`uvm_component_utils(${1:uvc}_coverage)
	${2:function1}_grp    ${2:function1}_grp_inst ;
	${3:function2}_grp    ${3:function2}_grp_inst ;
	  function new (string name = "${1:uvc}_cov", uvm_component parent);
	    super.new(name, parent);
	    ${1:function1}_grp_inst = new() ;
	  endfunction : new

	  function void build_phase(uvm_phase phase);
	    super.build_phase(phase);
	    // Get configuration from tb
	    if(!uvm_config_db#(virtual ${1:uvc}_cov_intf)::get(this,"","cov_vif", cov_vif)) begin
	      \`uvm_fatal(get_full_name(),"cannot get cov_intf object from config DB")
	    end
	    //Get has_coverage from tb or test
	    if(!uvm_config_db#(bit)::get(this,"","coverage_control", has_coverage)) begin
	      has_coverage = 1;//default is open cov
	    end
	    //Macro used to get the cov_flag
	    //"default" takes effect when config_db::get failed
	    //"cov_name" is a string representing the name of covergroup
	    \`define GET_COV_FLAG(default,"${2:function1}_grp_name") \
	    bit cov_flag; \
	    if(!uvm_config_db#(bit)::get(this,"","${2:function1}_grp_name", cov_flag)) begin \
	      cov_flag = default; \
	    end
	  endfunction:build_phase

	  task run_phase(uvm_phase phase);
	    if(has_coverage) begin
		fork
		    ${2:function1}_grp_sample();
		    //......  other sample task
		join
	    end
	  endtask:run_phase




	  task ${2:function1}_grp_sample();
	    `GET_COV_FLAG(0,"${2:function1}_grp")
	    if (cov_flag) begin
	      forever begin
	        @(posedge cov_vif.clk iff cov_vif.srst_n);
	        if(cov_vif.sin1) begin//sample event
	            ${2:function1}_grp_inst.sample();
	        end
	      end
	    end
	  endtask:${2:function1}_grp_sample
	  //..other sample task
	endclass:$1_coverage
snippet extern build_phase
	extern virtual function void build_phase(uvm_phase phase);
snippet extern connect_phase
	extern virtual function void connect_phase(uvm_phase phase);
snippet extern end_phase
	extern virtual function void end_of_elaboration_phase(uvm_phase phase);
snippet extern start_phase
	extern virtual function void start_of_simulation_phase(uvm_phase phase);
snippet extern run_phase
	extern virtual task run_phase(uvm_phase phase);
snippet extern pre_reset_phase
	extern virtual task pre_reset_phase(uvm_phase phase);
snippet extern reset_phase
	extern virtual task reset_phase(uvm_phase phase);
snippet extern post_reset_phase
	extern virtual task post_reset_phase(uvm_phase phase);
snippet extern pre_configure_phase
	extern virtual task pre_configure_phase(uvm_phase phase);
snippet extern configure_phase 
	extern virtual task configure_phase(uvm_phase phase);
snippet extern post_configure_phase 
	extern virtual task post_configure_phase(uvm_phase phase);
snippet extern pre_main_phase
	extern virtual task pre_min_phase(uvm_phase phase);
snippet extern main_phase
	extern virtual task main_phase(uvm_phase phase);  
snippet extern post_main_phase
	extern virtual task post_main_phase(uvm_phase phase);
snippet extern pre_shutdown_phase
	extern virtual task pre_shutdown_phase(uvm_phase phase);
snippet extern shutdown_phase
	extern virtual task shutdown_phase(uvm_phase phase);
snippet extern post_shutdown_phase
	extern virtual task post_shutdown_phase(uvm_phase phase);
snippet extern extract_phase
	extern virtual function void extract_phase(uvm_phase phase);
snippet extern check_phase
	extern virtual function void check_phase(uvm_phase phase);
snippet extern report_phase
	extern virtual function void report_phase(uvm_phase phase);
snippet extern final_phase
	extern virtual function void final_phase(uvm_phase phase);
snippet phase build_phase
	function void ${1:TM_FILENAME_BASE}${2:::}build_phase(uvm_phase phase);
	/*  note: Do not call super.build_phase() from any class that is extended from an UVM base class!  */
	/*  For more information see UVM Cookbook v1800.2 p.503  */
	  $3//super.build_phase(phase);
	  $0
	endfunction: build_phase
snippet phase run_phase
	task ${1:TM_FILENAME_BASE}${2:::}run_phase(uvm_phase phase);
	  phase.raise_objection(this);
	  \`uvm_info(${3:get_full_name()},"${4:run_phase} started, objection raised.", ${5:UVM_NONE})
	  $0
	  phase.drop_objection(this);
	  uvm_info($3, "$4 finished, objection dropped ", $5)
	endtask: run_phase
snippet phase pre_reset_phase
	task ${1:TM_FILENAME_BASE}${2:::}pre_reset_phase(uvm_phase phase);
	  $0
	endtask: pre_reset_phase

snippet phase reset_phase
	task ${1:TM_FILENAME_BASE}${2:::}reset_phase(uvm_phase phase);
	  phase.raise_objection(this);
	  \`uvm_info(${3:get_full_name()},"${4:reset_phase} started, objection raised.", ${5:UVM_NONE})
	  $0
	  phase.drop_objection(this);
	  uvm_info($3, "$4 finished, objection dropped ", $5)
	endtask: reset_phase

snippet phase post_reset_phase
	task ${1:TM_FILENAME_BASE}${2:::}post_reset_phase(uvm_phase phase);
	  $0
	endtask: post_reset_phase
snippet phase pre_configure_phase
	task ${1:TM_FILENAME_BASE}${2:::}pre_configure_phase(uvm_phase phase);
	  $0
	endtask: pre_configure_phase
snippet phase configure_phase
	task ${1:TM_FILENAME_BASE}${2:::}configure_phase(uvm_phase phase);
	  phase.raise_objection(this);
	  \`uvm_info(${3:get_full_name()},"${4:configure_phase} started, objection raised.", ${5:UVM_NONE})
	  $0
	  phase.drop_objection(this);
	  uvm_info($3, "$4 finished, objection dropped ", $5)
	endtask: configure_phase

snippet phase post_configure_phase
	task ${1:TM_FILENAME_BASE}${2:::}post_configure_phase(uvm_phase phase);
	  $0
	endtask: post_configure_phase

snippet phase pre_main_phase
	task void ${1:TM_FILENAME_BASE}${2:::}pre_main_phase(uvm_phase phase);
	  $0
	endtask: pre_main_phase
snippet phase main_phase
	task ${1:TM_FILENAME_BASE}${2:::}main_phase(uvm_phase phase);
	  phase.raise_objection(this);
	  \`uvm_info(${3:get_full_name()},"${4:main_phase} started, objection raised.", ${5:UVM_NONE})
	  $0
	  phase.drop_objection(this);
	  uvm_info($3, "$4 finished, objection dropped ", $5)
	endtask: main_phase

snippet phase post_main_phase
	task void ${1:TM_FILENAME_BASE}${2:::}post_main_phase(uvm_phase phase);
	  $0
	endtask: post_main_phase

snippet phase pre_shutdown_phase
	task ${1:TM_FILENAME_BASE}${2:::}pre_shutdown_phase(uvm_phase phase);
	  $0
	endtask: pre_shutdown_phase
snippet phase shutdown_phase
	task ${1:TM_FILENAME_BASE}${2:::}shutdown_phase(uvm_phase phase);
	  phase.raise_objection(this);
	  \`uvm_info(${3:get_full_name()},"${4:shutdown_phase} started, objection raised.", ${5:UVM_NONE})
	  $0
	  phase.drop_objection(this);
	  uvm_info($3, "$4 finished, objection dropped ", $5)
	endtask: shutdown_phase

snippet phase post_shutdown_phase
	task ${1:TM_FILENAME_BASE}${2:::}post_shutdown_phase(uvm_phase phase);
	  $0
	endtask: post_shutdown_phase

snippet phase extract_phase
	function void ${1:TM_FILENAME_BASE}${2:::}extract_phase(uvm_phase phase);
	  super.extract_phase(phase);
	  $0
	endfunction: extract_phase
snippet phase check_phase
	function void ${1:TM_FILENAME_BASE}${2:::}check_phase(uvm_phase phase);
	  super.check_phase(phase);
	  $0
	endfunction: check_phase
snippet phase report_phase
	function void ${1:TM_FILENAME_BASE}${2:::}report_phase(uvm_phase phase);
	  super.report_phase(phase);
	  $0
	endfunction: report_phase
snippet phase final_phase
	function void ${1:TM_FILENAME_BASE}${2:::}final_phase(uvm_phase phase);
	  super.final_phase(phase);
	  $0
	endfunction: final_phase
 
snippet uvm_objection
	    phase.raise_objection(this);
	    \`uvm_info(${1:get_full_name()},"${2:main_phase} started, objection raised.", ${3:UVM_NONE})
	    $0
	    phase.drop_objection(this);
	    uvm_info($1, "$2 finished, objection dropped ", $3)


	package ${1:package_name};
		${0}
	endpackage : $1

snippet uvm_object
	//  Class: $1
	//
	class ${1:my_class} extends ${2:uvm_object};
		\`uvm_object_utils($1);

		//  Group: Variables


		//  Group: Constraints


		//  Group: Functions

		//  Constructor: new
		function new(string name = "$1");
			super.new(name);
		endfunction: new
		$0
	endclass: $1


snippet uvm_object_with_parameters
	//  Class: $1
	//
	class ${1:my_class} #(${2:parameters}) extends ${3:uvm_object};
		typedef $1 #(${2/(\b(parameter|type)\s+([A-Za-z_][A-Za-z0-9_$]*)(\s*=\s*([A-Za-z0-9_$]+))?)*\b/$3/g}) this_type_t;
		\`uvm_object_param_utils(this_type_t);

		//  Group: Variables


		//  Group: Constraints


		//  Group: Functions

		//  Constructor: new
		function new(string name = "$1");
			super.new(name);
		endfunction: new
		$0
	endclass: $1


snippet uvm_component
	//  Class: $1
	//
	class ${1:my_class} extends ${2:uvm_component};
		\`uvm_component_utils($1);

		//  Group: Configuration Object(s)

		//  Var: config_obj
		${3:config_obj_t} config_obj;


		//  Group: Components


		//  Group: Variables


		//  Group: Functions

		//  Constructor: new
		function new(string name = "$1", uvm_component parent);
			super.new(name, parent);
		endfunction: new

		$0
	endclass: $1


snippet uvm_component_with_parameters
	//  Class: $1
	//
	class ${1:my_class} #(${2:parameters}) extends ${3:uvm_component};
		typedef $1 #(${2/(\b(parameter|type)\s+([A-Za-z_][A-Za-z0-9_$]*)(\s*=\s*([A-Za-z0-9_$]+))?)*\b/$3/g}) this_type_t;
		\`uvm_component_param_utils(this_type_t);

		//  Group: Configuration Object(s)

		//  Var: config_obj
		${4:config_obj_t} config_obj;


		//  Group: Components


		//  Group: Variables


		//  Constructor: new
		function new(string name = "$1", uvm_component parent);
			super.new(name, parent);
		endfunction: new

		$0
	endclass: $1


snippet uvm_component_extended
	//  Class: $1
	//
	class ${1:my_class} extends ${2:base_class};
		\`uvm_component_utils($1);

		//  Group: Configuration Object(s)


		//  Group: Components


		//  Group: Variables


		//  Group: Functions

		//  Constructor: new
		function new(string name = "$1", uvm_component parent);
			super.new(name, parent);
		endfunction: new

		/*---  UVM Build Phases            ---*/
		/*------------------------------------*/
		//  Function: build_phase
		extern function void build_phase(uvm_phase phase);
		//  Function: connect_phase
		extern function void connect_phase(uvm_phase phase);
		//  Function: end_of_elaboration_phase
		extern function void end_of_elaboration_phase(uvm_phase phase);

		/*---  UVM Run Phases              ---*/
		/*------------------------------------*/
		//  Function: start_of_simulation_phase
		extern function void start_of_simulation_phase(uvm_phase phase);
		//  Function: reset_phase
		extern task reset_phase(uvm_phase phase);
		//  Function: configure_phase
		extern task configure_phase(uvm_phase phase);
		//  Function: main_phase
		extern task main_phase(uvm_phase phase);
		//  Function: shutdown_phase
		extern task shutdown_phase(uvm_phase phase);

		/*---  UVM Cleanup Phases          ---*/
		/*------------------------------------*/
		//  Function: extract_phase
		extern function void extract_phase(uvm_phase phase);
		//  Function: report_phase
		extern function void report_phase(uvm_phase phase);
		$0
	endclass: $1


	/*----------------------------------------------------------------------------*/
	/*  UVM Build Phases                                                          */
	/*----------------------------------------------------------------------------*/
	function void $1::build_phase(uvm_phase phase);
		/*  note: Do not call super.build_phase() from any class that is extended from an UVM base class!  */
		/*  For more information see UVM Cookbook v1800.2 p.503  */
		// super.build_phase(phase);
	endfunction: build_phase


	function void $1::connect_phase(uvm_phase phase);
		super.connect_phase(phase);
	endfunction: connect_phase


	function void $1::end_of_elaboration_phase(uvm_phase phase);
		super.end_of_elaboration_phase(phase);
	endfunction: end_of_elaboration_phase


	/*----------------------------------------------------------------------------*/
	/*  UVM Run Phases                                                            */
	/*----------------------------------------------------------------------------*/
	function void $1::start_of_simulation_phase(uvm_phase phase);
		super.start_of_simulation_phase(phase);
	endfunction: start_of_simulation_phase


	task $1::reset_phase(uvm_phase phase);
	endtask: reset_phase


	task $1::configure_phase(uvm_phase phase);
	endtask: configure_phase


	task $1::main_phase(uvm_phase phase);
	endtask: main_phase


	task $1::shutdown_phase(uvm_phase phase);
	endtask: shutdown_phase


	/*----------------------------------------------------------------------------*/
	/*  UVM Cleanup Phases                                                        */
	/*----------------------------------------------------------------------------*/
	function void $1::report_phase(uvm_phase phase);
		super.report_phase(phase);
	endfunction: report_phase


	function void $1::extract_phase(uvm_phase phase);
		super.extract_phase(phase);
	endfunction: extract_phase



snippet uvm_sequence
	//  Class: $1
	//
	class ${1:my_class} extends ${2:uvm_sequence};
		\`uvm_object_utils($1);

		//  Group: Variables


		//  Group: Constraints


		//  Group: Functions

		//  Constructor: new
		function new(string name = "$1");
			super.new(name);
		endfunction: new

		//  Task: pre_start
		//  This task is a user-definable callback that is called before the optional 
		//  execution of <pre_body>.
		// extern virtual task pre_start();

		//  Task: pre_body
		//  This task is a user-definable callback that is called before the execution 
		//  of <body> ~only~ when the sequence is started with <start>.
		//  If <start> is called with ~call_pre_post~ set to 0, ~pre_body~ is not called.
		// extern virtual task pre_body();

		//  Task: pre_do
		//  This task is a user-definable callback task that is called ~on the parent 
		//  sequence~, if any. The sequence has issued a wait_for_grant() call and after
		//  the sequencer has selected this sequence, and before the item is randomized.
		//
		//  Although pre_do is a task, consuming simulation cycles may result in unexpected
		//  behavior on the driver.
		// extern virtual task pre_do(bit is_item);

		//  Function: mid_do
		//  This function is a user-definable callback function that is called after the 
		//  sequence item has been randomized, and just before the item is sent to the 
		//  driver.
		// extern virtual function void mid_do(uvm_sequence_item this_item);

		//  Task: body
		//  This is the user-defined task where the main sequence code resides.
		extern virtual task body();

		//  Function: post_do
		//  This function is a user-definable callback function that is called after the 
		//  driver has indicated that it has completed the item, using either this 
		//  item_done or put methods. 
		// extern virtual function void post_do(uvm_sequence_item this_item);

		//  Task: post_body
		//  This task is a user-definable callback task that is called after the execution 
		//  of <body> ~only~ when the sequence is started with <start>.
		//  If <start> is called with ~call_pre_post~ set to 0, ~post_body~ is not called.
		// extern virtual task post_body();

		//  Task: post_start
		//  This task is a user-definable callback that is called after the optional 
		//  execution of <post_body>.
		// extern virtual task post_start();
		$0
	endclass: $1

snippet uvm_sequence_with_parameters
	//  Class: $1
	//
	class ${1:my_class} #(${2:parameters}) extends ${3:uvm_sequence};
		typedef $1 #(${2/(\b(parameter|type)\s+([A-Za-z_][A-Za-z0-9_$]*)(\s*=\s*([A-Za-z0-9_$]+))?)*\b/$3/g}) this_type_t;
		\`uvm_object_param_utils(this_type_t);

		//  Group: Variables


		//  Group: Constraints


		//  Group: Functions

		//  Constructor: new
		function new(string name = "$1");
			super.new(name);
		endfunction: new

		//  Task: pre_start
		//  This task is a user-definable callback that is called before the optional 
		//  execution of <pre_body>.
		// extern virtual task pre_start();

		//  Task: pre_body
		//  This task is a user-definable callback that is called before the execution 
		//  of <body> ~only~ when the sequence is started with <start>.
		//  If <start> is called with ~call_pre_post~ set to 0, ~pre_body~ is not called.
		// extern virtual task pre_body();

		//  Task: pre_do
		//  This task is a user-definable callback task that is called ~on the parent 
		//  sequence~, if any. The sequence has issued a wait_for_grant() call and after
		//  the sequencer has selected this sequence, and before the item is randomized.
		//
		//  Although pre_do is a task, consuming simulation cycles may result in unexpected
		//  behavior on the driver.
		// extern virtual task pre_do(bit is_item);
		//  Function: mid_do
		//  This function is a user-definable callback function that is called after the 
		//  sequence item has been randomized, and just before the item is sent to the 
		//  driver.
		// extern virtual function void mid_do(uvm_sequence_item this_item);

		//  Task: body
		//  This is the user-defined task where the main sequence code resides.
		extern virtual task body();

		//  Function: post_do
		//  This function is a user-definable callback function that is called after the 
		//  driver has indicated that it has completed the item, using either this 
		//  item_done or put methods. 
		// extern virtual function void post_do(uvm_sequence_item this_item);

		//  Task: post_body
		//  This task is a user-definable callback task that is called after the execution 
		//  of <body> ~only~ when the sequence is started with <start>.
		//  If <start> is called with ~call_pre_post~ set to 0, ~post_body~ is not called.
		// extern virtual task post_body();

		//  Task: post_start
		//  This task is a user-definable callback that is called after the optional 
		//  execution of <post_body>.
		// extern virtual task post_start();
		$0
	endclass: $1

snippet uvm_sequence_functions
	// task ${1:my_class::}pre_start();
	// endtask: pre_start


	// task $1pre_body();
	// endtask: pre_body


	// task $1pre_do(bit is_item);
	// endtask: pre_do


	// function void $1mid_do(uvm_sequence_item this_item);
	// endfunction: mid_do


	task $1body();
		$0
	endtask: body


	// function void $1post_do(uvm_sequence_item this_item);
	// endfunction: post_do


	// task $1post_body();
	// endtask: post_body

	// task $1post_start();
	// endtask: post_start


snippet uvm_sequence_item
	//  Class: $1
	//
	class ${1:my_class} extends ${2:uvm_sequence_item};
		typedef $1 this_type_t;
		\`uvm_object_utils($1);

		//  Group: Variables


		//  Group: Constraints


		//  Group: Functions

		//  Constructor: new
		function new(string name = "$1");
			super.new(name);
		endfunction: new

		//  Function: do_copy
		// extern function void do_copy(uvm_object rhs);
		//  Function: do_compare
		// extern function bit do_compare(uvm_object rhs, uvm_comparer comparer);
		//  Function: convert2string
		// extern function string convert2string();
		//  Function: do_print
		// extern function void do_print(uvm_printer printer);
		//  Function: do_record
		// extern function void do_record(uvm_recorder recorder);
		//  Function: do_pack
		// extern function void do_pack();
		//  Function: do_unpack
		// extern function void do_unpack();
		$0
	endclass: $1


	/*----------------------------------------------------------------------------*/
	/*  Constraints                                                               */
	/*----------------------------------------------------------------------------*/




	/*----------------------------------------------------------------------------*/
	/*  Functions                                                                 */
	/*----------------------------------------------------------------------------*/



snippet uvm_sequence_item_with_parameters
	//  Class: $1
	//
	class ${1:my_class} #(${2:parameters}) extends ${3:uvm_sequence_item};
		typedef $1 #(${2/(\b(parameter|type)\s+([A-Za-z_][A-Za-z0-9_$]*)(\s*=\s*([A-Za-z0-9_$]+))?)*\b/$3/g}) this_type_t;
		\`uvm_object_param_utils(this_type_t);

		//  Group: Variables


		//  Group: Constraints


		//  Group: Functions

		//  Constructor: new
		function new(string name = "$1");
			super.new(name);
		endfunction: new

		//  Function: do_copy
		// extern function void do_copy(uvm_object rhs);
		//  Function: do_compare
		// extern function bit do_compare(uvm_object rhs, uvm_comparer comparer);
		//  Function: convert2string
		// extern function string convert2string();
		//  Function: do_print
		// extern function void do_print(uvm_printer printer);
		//  Function: do_record
		// extern function void do_record(uvm_recorder recorder);
		//  Function: do_pack
		// extern function void do_pack();
		//  Function: do_unpack
		// extern function void do_unpack();
		$0
	endclass: $1


	/*----------------------------------------------------------------------------*/
	/*  Constraints                                                               */
	/*----------------------------------------------------------------------------*/




	/*----------------------------------------------------------------------------*/
	/*  Functions                                                                 */
	/*----------------------------------------------------------------------------*/



snippet uvm_sequence_item_do_copy
	function void ${1:my_class}${2:::}do_copy(uvm_object rhs);
		this_type_t rhs_;

		if (!\$cast(rhs_, rhs)) begin
			\`uvm_error({this.get_name(), ".do_copy()"}, "Cast failed!");
			return;
		end
		// \`uvm_info({this.get_name(), ".do_copy()"}, "Cast succeded.", UVM_HIGH);

		/*  chain the copy with parent classes  */
		super.do_copy(rhs);

		/*  list of local properties to be copied  */
		// <this.property_name = rhs_.property_name>;
	endfunction: do_copy$0



snippet uvm_sequence_item_do_compare
	function bit ${1:my_class}${2:::}do_compare(uvm_object rhs, uvm_comparer comparer);
		this_type_t rhs_;

		if (!\$cast(rhs_, rhs)) begin
			\`uvm_error({this.get_name(), ".do_compare()"}, "Cast failed!");
			return;
		end
		// \`uvm_info({this.get_name(), ".do_compare()"}, "Cast succeded.", UVM_HIGH);

		/*  chain the compare with parent classes  */
		do_compare = super.do_compare(rhs, comparer);

		/*  list of local properties to be compared:  */
		do_compare &= (
			// <this.property_name == rhs_.property_name> &&
			// <this.property_name == rhs_.property_name>
		);
	endfunction: do_compare$0



snippet uvm_sequence_item_convert2string
	function string ${1:my_class}${2:::}convert2string();
		string s;

		/*  chain the convert2string with parent classes  */
		s = super.convert2string();

		/*  list of local properties to be printed:  */
		//  guide             0---4---8--12--16--20--24--28--32--36--40--44--48--
		// s = {s, \$sformatf("property_label      : 0x%0h\n", property_name)};
		// s = {s, \$sformatf("property_label      :   %0d\n", property_name)};

		return s;
	endfunction: convert2string$0



snippet uvm_sequence_item_do_print
	function void ${1:my_class}${2:::}do_print(uvm_printer printer)
		/*  chain the print with parent classes  */
		super.do_print(printer);

		/*  list of local properties to be printed:  */
		// printer.print_string("property_label", property_name);
		// printer.print_field_int("property_label", property_name, \$bits(property_name), UVM_HEX);
	endfunction: do_print$0

snippet uvm_sequence_item_do_record
	function void ${1:my_class}${2:::}do_record(uvm_recorder recorder);
		/*  chain the record with parent classes  */
		super.do_record(recorder);

		/*  list of local properties to be recorded:  */
		/*  note: use uvm_record_int, uvm_record_string, uvm_record_time, uvm_record_real for known basic types.  */
		// \`uvm_record_string("property_label", property_name);
		// \`uvm_record_int("property_label", property_name, \$bits(property_name), UVM_HEX);
	endfunction: do_record$0

snippet uvm_sequence_item_do_pack
	function void ${1:my_class}${2:::}do_pack(uvm_packer packer);
		/*  chain the pack with parent classes  */
		super.do_pack(packer);

		/*  list of local properties to be packed:  */
		//  note: look up the appropriate macro(s) for your properties!
		// \`uvm_pack_int(property_name);
		// \`uvm_pack_queue(property_name);
		// \`uvm_pack_string(property_name);
	endfunction: do_pack$0

snippet uvm_sequence_item_do_unpack
	function void ${1:my_class}${2:::}do_unpack(uvm_packer packer);
		/*  chain the unpack with parent classes  */
		super.do_unpack(packer);

		/*  list of local properties to be unpacked:  */
		//  note: look up the appropriate macro(s) for your properties!
		// \`uvm_unpack_int(property_name);
		// \`uvm_unpack_queue(property_name);
		// \`uvm_unpack_string(property_name);
	endfunction: do_unpack$0

